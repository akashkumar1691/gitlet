# gitlet
a version-control system that mimics some of the basic features of the popular version-control system git, but it is smaller and simpler, and thus named "gitlet"

## How to Use

<h3 id="init"><code class="language-plaintext highlighter-rouge">init</code></h3> <dl> <dt>Usage</dt> <dd><code class="language-plaintext highlighter-rouge">java gitlet.Main init</code></dd> <dt>Description</dt> <dd>Creates a new gitlet version-control system in the current directory. This system will automatically start with one commit: a commit that contains no files and has the commit message <code class="language-plaintext highlighter-rouge">initial commit</code>. It will have a single branch: <code class="language-plaintext highlighter-rouge">master</code>, which initially points to this initial commit, and <code class="language-plaintext highlighter-rouge">master</code> will be the current branch.</dd> </dl> 

<h3 id="add"><code class="language-plaintext highlighter-rouge">add</code></h3> <dl> <dt>Usage</dt> <dd><code class="language-plaintext highlighter-rouge">java gitlet.Main add [file name]</code></dd> <dt>Description</dt> <dd>Adds a copy of the file as it currently exists to the <em>staging area</em> (see the description of the <code class="language-plaintext highlighter-rouge">commit</code> command below).</dd> </dl> 

<h3 id="commit"><code class="language-plaintext highlighter-rouge">commit</code></h3> <dl> <dt>Usage</dt> <dd><code class="language-plaintext highlighter-rouge">java gitlet.Main commit [message]</code></dd> <dt>Description</dt> <dd>Saves a snapshot of certain files in the current commit and staging area so they can be restored at a later time, creating a new commit. The commit is said to be <em>tracking</em> the saved files. By default, each commit’s snapshot of files will be exactly the same as its parent commit’s snapshot of files; it will keep versions of files exactly as they are, and not update them. A commit will only update files it is tracking if they have been staged at the time of commit. In this case, the commit will now include the version of the file that was staged instead of the version it got from its parent. A commit will save and start tracking any files that were staged but weren’t tracked by its parent. Finally, files tracked in the current commit may be untracked in the new commit as a result of the <code class="language-plaintext highlighter-rouge">rm</code> command (see below for more information about the <code class="language-plaintext highlighter-rouge">rm</code> command). <p>The bottom line: By default a commit is the same as its parent. Staged and removed files are the updates to the commit.</p> <p>Some additional points about commit:</p> <ul> <li>The staging area is cleared after a commit.</li> <li>The commit command never adds, changes, or removes files in the working directory (other than those in the <code class="language-plaintext highlighter-rouge">.gitlet</code> directory). The <code class="language-plaintext highlighter-rouge">rm</code> command <em>will</em> remove such files, as well as somehow marking them to be untracked by <code class="language-plaintext highlighter-rouge">commit</code>.</li> <li>Any changes made to files after staging or removal are ignored by the <code class="language-plaintext highlighter-rouge">commit</code> command, which <em>only</em> modifies the contents of the <code class="language-plaintext highlighter-rouge">.gitlet</code> directory. For example, if you remove a tracked file using the Unix <code class="language-plaintext highlighter-rouge">rm</code> command (rather than <code class="language-plaintext highlighter-rouge">gitlet</code>’s command of the same name), it has no effect on the next commit, which will still contain the version of the file before it was deleted.</li> <li>After the commit command, the new commit is added as a new node in the commit tree.</li> <li>The commit just made becomes the “current commit”, and the current branch’s head pointer now points to it. The branch’s previous head commit is this now commit’s parent commit.</li> <li>Each commit should contain the date time it was made.</li> <li>Each commit has a log message associated with it that describes the changes to the files in the commit. This is specified by the user. The entire message should take up only one entry in the array <code class="language-plaintext highlighter-rouge">args</code> that is passed to <code class="language-plaintext highlighter-rouge">main</code>. To include multiword messages, you’ll have to surround them in quotes.</li> <li>Each commit is identified by its SHA-1 id, which must include the file (blob) references of its files, parent reference, log message, and commit time.</li> </ul> </dd>  </dl> 

<h3 id="rm"><code class="language-plaintext highlighter-rouge">rm</code></h3> <dl> <dt>Usage</dt> <dd><code class="language-plaintext highlighter-rouge">java gitlet.Main rm [file name]</code></dd> <dt>Description</dt> <dd>Untrack the file; that is, indicate  that it is <em>not</em> to be included in the next commit, even if it is tracked in the current commit (the current commit will eventually become the next commit’s parent).  </ul> </dd> </dl>

<h3 id="log"><code class="language-plaintext highlighter-rouge">log</code></h3> <dl> <dt>Usage</dt> <dd><code class="language-plaintext highlighter-rouge">java gitlet.Main log</code></dd> <dt>Description</dt> <dd>Starting at the current head commit, display information about each commit backwards along the commit tree until the initial commit. This set of commit nodes is called the commit’s <em>history</em>. For every node in this history, the information it should display is the commit id, the time the commit was made, and the commit message.</dl>

<h3 id="global-log"><code class="language-plaintext highlighter-rouge">global-log</code></h3> <dl> <dt>Usage</dt> <dd><code class="language-plaintext highlighter-rouge">java gitlet.Main global-log</code></dd> <dt>Description</dt> <dd>Like log, except displays information about all commits ever made. The order of the commits does not matter.</dd> </dl>

<h3 id="find"><code class="language-plaintext highlighter-rouge">find</code></h3> <dl> <dt>Usage</dt> <dd><code class="language-plaintext highlighter-rouge">java gitlet.Main find [commit message]</code></dd> <dt>Description</dt> <dd>Prints out the ids of all commits that have the given commit message, one per line. If there are multiple such commits, it prints the ids out on separate lines. The commit message is a single operand in the argument of the main method; to indicate a multiword message, put the operand in quotation marks (just like we did for the commit command above). This command must return every matching commit that has ever been made, even those that are not on the current branch. Order of the ids outputted does not matter.</dd> </dl>

<h3 id="status"><code class="language-plaintext highlighter-rouge">status</code></h3> <dl> <dt>Usage</dt> <dd><code class="language-plaintext highlighter-rouge">java gitlet.Main status</code></dd> <dt>Description</dt> <dd>Displays what branches currently exist, and marks the current branch with a <code class="language-plaintext highlighter-rouge">*</code>. Also displays what files have been staged or marked for untracking. </dd> </dl> 

<h3 id="checkout"><code class="language-plaintext highlighter-rouge">checkout</code></h3> <p>Checkout is a kind of general command that can do a few different things depending on what its arguments are. There are 3 possible use cases. In each section below, you’ll see 3 bullet points. Each corresponds to the respective usage of checkout.</p> <dl> <dt>Usages</dt> <dd> <ol> <li><code class="language-plaintext highlighter-rouge">java gitlet.Main checkout -- [file name]</code></li> <li><code class="language-plaintext highlighter-rouge">java gitlet.Main checkout [commit id] -- [file name]</code></li> <li><code class="language-plaintext highlighter-rouge">java gitlet.Main checkout [branch name]</code></li> </ol> </dd> <dt>Descriptions</dt> <dd> <ol> <li>Takes the version of the file as it exists in the head commit, the front of the current branch, and puts it in the working directory, overwriting the version of the file that’s already there if there is one. The new version of the file is not staged.</li> <li>Takes the version of the file as it exists in the commit with the given id, and puts it in the working directory, overwriting the version of the file that’s already there if there is one. The new version of the file is not staged.</li> <li>Takes all files in the commit at the head of the given branch, and puts them in the working directory, overwriting the versions of the files that are already there if they exist. Also, at the end of this command, the branch given as an argument to this command (specified by <code class="language-plaintext highlighter-rouge">branch name</code> above) will now be considered the current branch (HEAD). Any files that are tracked in the current branch but are not present in the branch you are checking out are deleted. The staging area is cleared, unless the branch you are checking out to is the current branch (see <strong>Failure cases</strong> below).</li> </ol> </dd> </dl>

<h3 id="branch"><code class="language-plaintext highlighter-rouge">branch</code></h3> <dl> <dt>Usage</dt> <dd><code class="language-plaintext highlighter-rouge">java gitlet.Main branch [branch name]</code></dd> <dt>Description</dt> <dd>Creates a new branch with the given name <code class="language-plaintext highlighter-rouge">branch name</code>, and points the branch at the current head node. A branch is nothing more than a name for a reference (a SHA-1 identifier) to a commit node. This command does NOT immediately switch to the newly created branch (just as in real <code class="language-plaintext highlighter-rouge">git</code>). The default branch that is created when you initialize your repository is called <code class="language-plaintext highlighter-rouge">master</code>.</dd> </dl>

<h3 id="rm-branch"><code class="language-plaintext highlighter-rouge">rm-branch</code></h3> <dl> <dt>Usage</dt> <dd><code class="language-plaintext highlighter-rouge">java gitlet.Main rm-branch [branch name]</code></dd> <dt>Description</dt> <dd>Deletes the branch with the given name. This only means to delete the pointer associated with the branch; it does not mean to delete all commits that were created under the branch, or anything like that.</dd> </dl> 

<h3 id="reset"><code class="language-plaintext highlighter-rouge">reset</code></h3> <dl> <dt>Usage</dt> <dd><code class="language-plaintext highlighter-rouge">java gitlet.Main reset [commit id]</code></dd> <dt>Description</dt> <dd>Checks out all the files tracked by the given commit. Removes tracked files that are not being tracked in the given commit. Moves the current branch’s pointer and the head pointer to that commit node. See the intro for an example of what happens to the head pointer after using reset. The <code class="language-plaintext highlighter-rouge">[commit id]</code> may be abbreviated as for <code class="language-plaintext highlighter-rouge">checkout</code>. The staging area is cleared. The command is essentially <code class="language-plaintext highlighter-rouge">checkout</code> of an arbitrary commit that also changes the current branch head pointer.</dd> </dl> 

<h3 id="merge"><code class="language-plaintext highlighter-rouge">merge</code></h3> <dl> <dt>Usage</dt> <dd><code class="language-plaintext highlighter-rouge">java gitlet.Main merge [branch name]</code></dd> <dt>Description</dt> <dd>Merges files from the given branch into the current branch. </dd> </dl>
